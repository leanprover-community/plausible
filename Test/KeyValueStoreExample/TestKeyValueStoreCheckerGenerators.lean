import Test.KeyValueStoreExample.KeyValueStore
import Plausible.Arbitrary
import Plausible.DeriveArbitrary
import Plausible.Chamelean.ArbitrarySizedSuchThat
import Plausible.Chamelean.DeriveChecker
import Plausible.Chamelean.DeriveConstrainedProducer
import Plausible.Chamelean.EnumeratorCombinators
import Plausible.Chamelean.GeneratorCombinators

open Plausible
open KeyValueStore

-- Suppress warnings for unused variables in derived generators/checkers
set_option linter.unusedVariables false

-- Suppress warnings for redundant pattern-match cases in derived generators/checkers
set_option match.ignoreUnusedAlts true

/-- We override the default `Arbitrary` for `String`s so that we only produce strings of length 1
    where the string is a single letter from `A` to `I` -/
instance instKeyValueStoreArbitraryString : Arbitrary String where
  arbitrary := GeneratorCombinators.elementsWithDefault "A" ["A", "B", "C", "D", "E", "F", "G", "H", "I"]

---------------------------------------------------------------------------------------------------------------------------------------
-- Derived Checkers & Generators (everything below in this file is automatically generated by Chamelean)
---------------------------------------------------------------------------------------------------------------------------------------

/--
info: Try this generator: instance : ArbitrarySizedSuchThat (List (String × String)) (fun s1_1 => KeyValueStore.RemoveKV k_1 s1_1 s2_1) where
  arbitrarySizedST :=
    let rec aux_arb (initSize : Nat) (size : Nat) (k_1 : String) (s2_1 : List (String × String)) :
      Plausible.Gen (List (String × String)) :=
      (match size with
      | Nat.zero =>
        GeneratorCombinators.backtrack
          [(1,
              match s2_1 with
              | List.nil => return List.nil
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)]
      | Nat.succ size' =>
        GeneratorCombinators.backtrack
          [(1,
              match s2_1 with
              | List.nil => return List.nil
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (Nat.succ size', do
              let s1 ← aux_arb initSize size' k_1 s2_1;
              do
                let v ← Plausible.Arbitrary.arbitrary;
                return List.cons (Prod.mk k_1 v) s1),
            (Nat.succ size',
              match s2_1 with
              | List.cons (Prod.mk k2 v2) s2 =>
                match DecOpt.decOpt (Eq (bne k_1 k2) (Bool.true)) initSize with
                | Except.ok Bool.true => do
                  let s1 ← aux_arb initSize size' k_1 s2;
                  return List.cons (Prod.mk k2 v2) s1
                | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)])
    fun size => aux_arb size size k_1 s2_1
-/
#guard_msgs(info, drop warning) in
#derive_generator (fun (s1 : List (String × String)) => KeyValueStore.RemoveKV k s1 s2)

/--
info: Try this generator: instance : ArbitrarySizedSuchThat (List (String × String)) (fun s2_1 => KeyValueStore.RemoveKV k_1 s1_1 s2_1) where
  arbitrarySizedST :=
    let rec aux_arb (initSize : Nat) (size : Nat) (k_1 : String) (s1_1 : List (String × String)) :
      Plausible.Gen (List (String × String)) :=
      (match size with
      | Nat.zero =>
        GeneratorCombinators.backtrack
          [(1,
              match s1_1 with
              | List.nil => return List.nil
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)]
      | Nat.succ size' =>
        GeneratorCombinators.backtrack
          [(1,
              match s1_1 with
              | List.nil => return List.nil
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (Nat.succ size',
              match s1_1 with
              | List.cons (Prod.mk u_3 v) s1 =>
                match DecOpt.decOpt (BEq.beq u_3 k_1) initSize with
                | Except.ok Bool.true => do
                  let s2_1 ← aux_arb initSize size' k_1 s1;
                  return s2_1
                | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (Nat.succ size',
              match s1_1 with
              | List.cons (Prod.mk k2 v2) s1 =>
                match DecOpt.decOpt (Eq (bne k_1 k2) (Bool.true)) initSize with
                | Except.ok Bool.true => do
                  let s2 ← aux_arb initSize size' k_1 s1;
                  return List.cons (Prod.mk k2 v2) s2
                | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)])
    fun size => aux_arb size size k_1 s1_1
-/
#guard_msgs(info, drop warning) in
#derive_generator (fun (s2 : List (String × String)) => KeyValueStore.RemoveKV k s1 s2)


/--
info: Try this generator: instance : ArbitrarySizedSuchThat (List (String × String)) (fun s1_1 => KeyValueStore.AddKV k_1 v_1 s1_1 s2_1) where
  arbitrarySizedST :=
    let rec aux_arb (initSize : Nat) (size : Nat) (k_1 : String) (v_1 : String) (s2_1 : List (String × String)) :
      Plausible.Gen (List (String × String)) :=
      (match size with
      | Nat.zero =>
        GeneratorCombinators.backtrack
          [(1,
              match s2_1 with
              | List.cons (Prod.mk u_4 u_5) s1_1 =>
                match DecOpt.decOpt (BEq.beq u_4 k_1) initSize with
                | Except.ok Bool.true =>
                  match DecOpt.decOpt (BEq.beq u_5 v_1) initSize with
                  | Except.ok Bool.true => return s1_1
                  | _ => MonadExcept.throw Plausible.Gen.genericFailure
                | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)]
      | Nat.succ size' =>
        GeneratorCombinators.backtrack
          [(1,
              match s2_1 with
              | List.cons (Prod.mk u_4 u_5) s1_1 =>
                match DecOpt.decOpt (BEq.beq u_4 k_1) initSize with
                | Except.ok Bool.true =>
                  match DecOpt.decOpt (BEq.beq u_5 v_1) initSize with
                  | Except.ok Bool.true => return s1_1
                  | _ => MonadExcept.throw Plausible.Gen.genericFailure
                | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            ])
    fun size => aux_arb size size k_1 v_1 s2_1
-/
#guard_msgs(info, drop warning) in
#derive_generator (fun (s1 : List (String × String)) => KeyValueStore.AddKV k v s1 s2)

/--
info: Try this generator: instance : ArbitrarySizedSuchThat (List (String × String)) (fun s2_1 => KeyValueStore.AddKV k_1 v_1 s1_1 s2_1) where
  arbitrarySizedST :=
    let rec aux_arb (initSize : Nat) (size : Nat) (k_1 : String) (v_1 : String) (s1_1 : List (String × String)) :
      Plausible.Gen (List (String × String)) :=
      (match size with
      | Nat.zero => GeneratorCombinators.backtrack [(1, return List.cons (Prod.mk k_1 v_1) s1_1)]
      | Nat.succ size' => GeneratorCombinators.backtrack [(1, return List.cons (Prod.mk k_1 v_1) s1_1), ])
    fun size => aux_arb size size k_1 v_1 s1_1
-/
#guard_msgs(info, drop warning) in
#derive_generator (fun (s2 : List (String × String)) => KeyValueStore.AddKV k v s1 s2)

/--
info: Try this generator: instance : ArbitrarySizedSuchThat String (fun v_1 => KeyValueStore.AddKV k_1 v_1 x_1_1 s2_1) where
  arbitrarySizedST :=
    let rec aux_arb (initSize : Nat) (size : Nat) (k_1 : String) (x_1_1 : List (String × String))
      (s2_1 : List (String × String)) : Plausible.Gen String :=
      (match size with
      | Nat.zero =>
        GeneratorCombinators.backtrack
          [(1,
              match s2_1 with
              | List.cons (Prod.mk u_4 v_1) u_5 =>
                match DecOpt.decOpt (BEq.beq u_4 k_1) initSize with
                | Except.ok Bool.true =>
                  match DecOpt.decOpt (BEq.beq u_5 x_1_1) initSize with
                  | Except.ok Bool.true => return v_1
                  | _ => MonadExcept.throw Plausible.Gen.genericFailure
                | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)]
      | Nat.succ size' =>
        GeneratorCombinators.backtrack
          [(1,
              match s2_1 with
              | List.cons (Prod.mk u_4 v_1) u_5 =>
                match DecOpt.decOpt (BEq.beq u_4 k_1) initSize with
                | Except.ok Bool.true =>
                  match DecOpt.decOpt (BEq.beq u_5 x_1_1) initSize with
                  | Except.ok Bool.true => return v_1
                  | _ => MonadExcept.throw Plausible.Gen.genericFailure
                | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            ])
    fun size => aux_arb size size k_1 x_1_1 s2_1
-/
#guard_msgs(info, drop warning) in
#derive_generator (fun (v : String) => KeyValueStore.AddKV k v x_1 s2)

/--
info: Try this checker:
  instance : DecOpt (KeyValueStore.LookupKV s_1 kv_1) where
  decOpt :=
    let rec aux_dec (initSize : Nat) (size : Nat) (s_1 : List (String × String))
      (kv_1 : StateResult × String × Nat × String) : Except Plausible.GenError Bool :=
      (match size with
      | Nat.zero =>
        DecOpt.checkerBacktrack
          [fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.NoSuchKeyFailure) (Prod.mk k (Prod.mk (Nat.zero) v)) =>
              match s_1 with
              | List.nil => Except.ok Bool.true
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false,
            fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk u_2 (Prod.mk (Nat.zero) u_3)) =>
              match s_1 with
              | List.cons (Prod.mk k v) s =>
                DecOpt.andOptList [DecOpt.decOpt (BEq.beq u_2 k) initSize, DecOpt.decOpt (BEq.beq u_3 v) initSize]
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false,
            fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk u_2 (Prod.mk (Nat.succ n) u_3)) =>
              match s_1 with
              | List.cons (Prod.mk k v) (List.nil) =>
                DecOpt.andOptList [DecOpt.decOpt (BEq.beq u_2 k) initSize, DecOpt.decOpt (BEq.beq u_3 v) initSize]
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false]
      | Nat.succ size' =>
        DecOpt.checkerBacktrack
          [fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.NoSuchKeyFailure) (Prod.mk k (Prod.mk (Nat.zero) v)) =>
              match s_1 with
              | List.nil => Except.ok Bool.true
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false,
            fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk u_2 (Prod.mk (Nat.zero) u_3)) =>
              match s_1 with
              | List.cons (Prod.mk k v) s =>
                DecOpt.andOptList [DecOpt.decOpt (BEq.beq u_2 k) initSize, DecOpt.decOpt (BEq.beq u_3 v) initSize]
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false,
            fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk u_2 (Prod.mk (Nat.succ n) u_3)) =>
              match s_1 with
              | List.cons (Prod.mk k v) (List.nil) =>
                DecOpt.andOptList [DecOpt.decOpt (BEq.beq u_2 k) initSize, DecOpt.decOpt (BEq.beq u_3 v) initSize]
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false,
            fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk k1 (Prod.mk n' v1)) =>
              match s_1 with
              | List.cons (Prod.mk k2 v2) s =>
                EnumeratorCombinators.enumerating Enum.enum
                  (fun n =>
                    DecOpt.andOptList
                      [aux_dec initSize size' s (Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk k1 (Prod.mk n v1))),
                        DecOpt.decOpt (Eq n' (KeyValueStore.ver k1 k2 n)) initSize])
                  (min 2 initSize)
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false,
            fun _ =>
            match kv_1 with
            | Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk k1 (Prod.mk n' v1)) =>
              match s_1 with
              | List.cons (Prod.mk k2 v2) s =>
                EnumeratorCombinators.enumerating Enum.enum
                  (fun n =>
                    DecOpt.andOptList
                      [aux_dec initSize size' s
                          (Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk k1 (Prod.mk n v1))),
                        DecOpt.decOpt (Eq n' (KeyValueStore.ver k1 k2 n)) initSize])
                  (min 2 initSize)
              | _ => Except.ok Bool.false
            | _ => Except.ok Bool.false])
    fun size => aux_dec size size s_1 kv_1
-/
#guard_msgs(info, drop warning, whitespace:=lax) in
#derive_checker (KeyValueStore.LookupKV s kv)

/--
info: Try this generator: instance : ArbitrarySizedSuchThat (List (String × String)) (fun s1_1 => KeyValueStore.LookupKV s1_1 kv_1) where
  arbitrarySizedST :=
    let rec aux_arb (initSize : Nat) (size : Nat) (kv_1 : StateResult × String × Nat × String) :
      Plausible.Gen (List (String × String)) :=
      (match size with
      | Nat.zero =>
        GeneratorCombinators.backtrack
          [(1,
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.NoSuchKeyFailure) (Prod.mk k (Prod.mk (Nat.zero) v)) =>
                return List.nil
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (1,
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk k (Prod.mk (Nat.zero) v)) => do
                let s ← Plausible.Arbitrary.arbitrary;
                return List.cons (Prod.mk k v) s
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (1,
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk k (Prod.mk (Nat.succ n) v)) =>
                return List.cons (Prod.mk k v) (List.nil)
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)]
      | Nat.succ size' =>
        GeneratorCombinators.backtrack
          [(1,
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.NoSuchKeyFailure) (Prod.mk k (Prod.mk (Nat.zero) v)) =>
                return List.nil
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (1,
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk k (Prod.mk (Nat.zero) v)) => do
                let s ← Plausible.Arbitrary.arbitrary;
                return List.cons (Prod.mk k v) s
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (1,
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk k (Prod.mk (Nat.succ n) v)) =>
                return List.cons (Prod.mk k v) (List.nil)
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (Nat.succ size',
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk k1 (Prod.mk n' v1)) => do
                let k2 ← Plausible.Arbitrary.arbitrary;
                do
                  let n ← Plausible.Arbitrary.arbitrary;
                  do
                    let v2 ← Plausible.Arbitrary.arbitrary;
                    match DecOpt.decOpt (Eq n' (KeyValueStore.ver k1 k2 n)) initSize with
                      | Except.ok Bool.true => do
                        let s ←
                          aux_arb initSize size' (Prod.mk (KeyValueStore.StateResult.Ok) (Prod.mk k1 (Prod.mk n v1)));
                        return List.cons (Prod.mk k2 v2) s
                      | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure),
            (Nat.succ size',
              match kv_1 with
              | Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk k1 (Prod.mk n' v1)) => do
                let k2 ← Plausible.Arbitrary.arbitrary;
                do
                  let n ← Plausible.Arbitrary.arbitrary;
                  do
                    let v2 ← Plausible.Arbitrary.arbitrary;
                    match DecOpt.decOpt (Eq n' (KeyValueStore.ver k1 k2 n)) initSize with
                      | Except.ok Bool.true => do
                        let s ←
                          aux_arb initSize size'
                              (Prod.mk (KeyValueStore.StateResult.NoSuchVersionFailure) (Prod.mk k1 (Prod.mk n v1)));
                        return List.cons (Prod.mk k2 v2) s
                      | _ => MonadExcept.throw Plausible.Gen.genericFailure
              | _ => MonadExcept.throw Plausible.Gen.genericFailure)])
    fun size => aux_arb size size kv_1
-/
#guard_msgs(info, drop warning) in
#derive_generator (fun (s1 : List (String × String)) => KeyValueStore.LookupKV s1 kv)

#derive_checker (KeyValueStore.AddKV k2 v s_1 s2)

#derive_generator (fun (s : List (String × String)) => KeyValueStore.EvalStateApiCall s x)

#derive_generator (fun (kv : StateResult × String × Nat × String) => KeyValueStore.LookupKV s kv)

#derive_generator (fun (nb : Nat × List (String × String)) => KeyValueStore.GetBucket s nb)

#derive_generator (fun (foo : StateAPICall × StateResult × List (String × String)) => KeyValueStore.EvalStateApiCall x foo)

#derive_generator (fun (crns : APICall × Result × (Nat × List (Nat × List (String × String)))) => KeyValueStore.EvalApiCall s crns)

#derive_generator (fun (o : List (APICall × Result) × (Nat × List (Nat × List (String × String)))) => KeyValueStore.EvalApiCalls s o)


/- Uncommenting the following line results in random sequences of API Calls, such as:

```lean
 ([(APICall.CreateBucket, Result.Created 0),
  (APICall.OpBucket 0 (StateAPICall.Delete "B"),
   Result.OpResult (StateResult.NoSuchKeyFailure)),
  (APICall.CreateBucket, Result.Created 1),
  (APICall.DeleteBucket 0, Result.Removed),
  (APICall.CreateBucket, Result.Created 2),
  (APICall.CreateBucket, Result.Created 3),
  (APICall.DeleteBucket 1, Result.Removed),
  (APICall.CreateBucket, Result.Created 4),
  (APICall.DeleteBucket 2, Result.Removed),
  (APICall.OpBucket 3 (StateAPICall.Get "E" none),
   Result.OpResult (StateResult.NoSuchKeyFailure)),
  (APICall.CreateBucket, Result.Created 5),
  (APICall.OpBucket 3 (StateAPICall.Append "B" "D"),
   Result.OpResult (StateResult.NoSuchKeyFailure)),
  (APICall.DeleteBucket 3, Result.Removed),
  (APICall.CreateBucket, Result.Created 6)],
 7,
 [(6, []), (5, []), (4, [])])
```

-/
-- #eval Gen.run (ArbitrarySizedSuchThat.arbitrarySizedST (fun crs => KeyValueStore.EvalApiCalls (0, []) crs) 20) 20
