/-
Copyright (c) 2022 Henrik Böving. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Henrik Böving
-/

/-!
# Rand Monad and Random Class

This module provides tools for formulating computations guided by randomness and for
defining objects that can be created randomly.

## Main definitions

* `RandT` and `RandGT` monad transformers for computations guided by randomness;
* `Rand` and `RandG` monads as special cases of the above
* `Random` class for objects that can be generated randomly;
  * `random` to generate one object;
* `BoundedRandom` class for objects that can be generated randomly inside a range;
  * `randomR` to generate one object inside a range;
* `runRand` to run a randomized computation inside any monad that has access to `stdGenRef`.

## References

* Similar library in Haskell: https://hackage.haskell.org/package/MonadRandom

-/

set_option linter.missingDocs true

namespace Plausible

/-- A monad transformer to generate random objects using the generic generator type `g` -/
abbrev RandGT (g : Type) := StateT (ULift g)
/-- A monad to generate random objects using the generator type `g`. -/
abbrev RandG (g : Type) := RandGT g Id

/-- A monad transformer to generate random objects using the generator type `StdGen`.
`RandT m α` should be thought of a random value in `m α`. -/
abbrev RandT := RandGT StdGen

/-- A monad to generate random objects using the generator type `StdGen`. -/
abbrev Rand := RandG StdGen

instance [MonadLift m n] : MonadLiftT (RandGT g m) (RandGT g n) where
  monadLift x := fun s => x s

/-- `Random m α` gives us machinery to generate values of type `α` in the monad `m`.

Note that `m` is a parameter as some types may only be sampleable with access to a certain monad. -/
class Random (m) (α : Type u) where
  /--
  Generate a value of type `α` randomly using generator `g`.
  -/
  random [RandomGen g] : RandGT g m α

/-- `BoundedRandom m α` gives us machinery to generate values of type `α` between certain bounds in
the monad `m`. -/
class BoundedRandom (m) (α : Type u) [LE α] where
  /--
  Generate a value of type `α` between `lo` and `hi` randomly using generator `g`.
  -/
  randomR {g : Type} (lo hi : α) (h : lo ≤ hi) [RandomGen g] : RandGT g m {a // lo ≤ a ∧ a ≤ hi}

/-- Given a random generator for `α`, we can convert it to a random generator for `ULift α`. -/
@[inline]
protected def RandT.up {α : Type u} {m : Type u → Type w} {m' : Type (max u v) → Type w'}
    {g : Type} [RandomGen g] [Monad m] [Monad m']
    (m_up : ∀ {α}, m α → m' (ULift α)) (x : RandGT g m α) :
    RandGT g m' (ULift.{v} α) := do
  let ⟨val, gen⟩ ←  m_up <| x.run ⟨(← get).down⟩
  set <| ULift.up gen.down
  return ⟨val⟩

/-- Given a random generator for `ULift α`, we can convert it to a random generator for `α`. -/
@[inline]
protected def RandT.down {α : Type u} {m : Type (max u v) → Type w} {m' : Type u → Type w'}
    {g : Type} [RandomGen g] [Monad m] [Monad m']
    (m_down : ∀ {α}, m (ULift α) → m' α) (x : RandGT g m (ULift.{v} α) ) :
    RandGT g m' α := do
  let gen := (← get).down
  let ⟨val, gen⟩ ← m_down do
    let ⟨⟨val⟩, ⟨gen⟩⟩ ← x.run ⟨gen⟩
    pure <| .up (val, gen)
  set <| ULift.up gen
  return val

namespace Rand
/-- Generate one more `Nat` -/
def next [RandomGen g] [Monad m] : RandGT g m Nat := do
  let rng := (← get).down
  let (res, new) := RandomGen.next rng
  set (ULift.up new)
  return res

/-- Create a new random number generator distinct from the one stored in the state -/
def split {g : Type} [RandomGen g] [Monad m] : RandGT g m g := do
  let rng := (← get).down
  let (r1, r2) := RandomGen.split rng
  set (ULift.up r1)
  return r2

/-- Get the range of Nat that can be generated by the generator `g` -/
def range {g : Type} [RandomGen g] [Monad m] : RandGT g m (Nat × Nat) := do
  let rng := (← get).down
  return RandomGen.range rng

/-- Given a random generator for `α`, we can convert it to a random generator for `ULift α`. -/
@[inline]
protected def up {α : Type u} {g : Type} [RandomGen g] (x : RandG g α) :
    RandG g (ULift.{v} α) := do
  RandT.up (fun x => pure ⟨Id.run x⟩) x

/-- Given a random generator for `ULift α`, we can convert it to a random generator for `α`. -/
@[inline]
protected def down {α : Type u} {g : Type} [RandomGen g] (x : RandG g (ULift.{v} α)) :
    RandG g α :=
  RandT.down (fun x => pure (Id.run x).down) x

end Rand

namespace Random

open Rand

variable [Monad m]

/-- Generate a random value of type `α`. -/
def rand (α : Type u) [Random m α] [RandomGen g] : RandGT g m α := Random.random

/-- Generate a random value of type `α` between `x` and `y` inclusive. -/
def randBound (α : Type u) [LE α] [BoundedRandom m α] (lo hi : α) (h : lo ≤ hi) [RandomGen g] :
    RandGT g m {a // lo ≤ a ∧ a ≤ hi} :=
  BoundedRandom.randomR lo hi h

/--
Generate a random `Fin`.
-/
def randFin {n : Nat} [RandomGen g] : RandGT g m (Fin n.succ) :=
  fun ⟨g⟩ => return randNat g 0 n |>.map (Fin.ofNat' _) ULift.up

instance {n : Nat} : Random m (Fin n.succ) where
  random := randFin

/--
Generate a random `Bool`.
-/
def randBool [RandomGen g] : RandGT g m Bool :=
  return (← rand (Fin 2)) == 1

instance : Random m Bool where
  random := randBool

instance : BoundedRandom m Nat where
  randomR lo hi h _ := do
    let z ← rand (Fin (hi - lo).succ)
    return ⟨lo + z.val, by omega, by omega⟩

instance : BoundedRandom m Int where
  randomR lo hi h _ := do
    let ⟨z, _, h2⟩ ← randBound Nat 0 (Int.natAbs <| hi - lo) (by omega)
    return ⟨z + lo, by omega, by omega⟩

instance {n : Nat} : BoundedRandom m (Fin n) where
  randomR lo hi h _ := do
    let ⟨r, h1, h2⟩ ← randBound Nat lo.val hi.val h
    return ⟨⟨r, by omega⟩, h1, h2⟩

instance {n : Nat} : BoundedRandom m (BitVec n) where
  randomR lo hi h _ := do
    let ⟨r, h1, h2⟩ ← randBound Nat lo.toNat hi.toNat h
    return ⟨⟨r, by omega⟩, h1, h2⟩

end Random

open IO
variable {m : Type _ → Type _}
variable [Monad m] [MonadLiftT (ST RealWorld) m]

/--
Computes a `RandT m α` using the global `stdGenRef` as RNG.

Note that:
- `stdGenRef` is not necessarily properly seeded on program startup
  as of now and will therefore be deterministic.
- `stdGenRef` is not thread local, hence two threads accessing it
  at the same time will get the exact same generator.
-/
def runRand (cmd : RandT m α) : m α := do
  let stdGen ← stdGenRef.get
  let (res, new) ← StateT.run cmd (ULift.up stdGen)
  let _ ← stdGenRef.set new.down
  return res

/--
Run the random computaton `cmd` with `seed` for the RNG.
-/
def runRandWith (seed : Nat) (cmd : RandT m α) : m α := do
  return (← cmd.run (ULift.up <| mkStdGen seed)).1

end Plausible
